--- third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.exp~	2012-12-13 07:06:35.109949206 -0600
+++ third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.exp	2012-12-14 17:28:39.346932470 -0600
@@ -435,6 +435,7 @@
 __ZN3WTF23callOnMainThreadAndWaitEPFvPvES0_
 __ZN3WTF23dayInMonthFromDayInYearEib
 __ZN3WTF23waitForThreadCompletionEjPPv
+__ZN3WTF27monotonicallyIncreasingTimeEv
 __ZN3WTF27releaseFastMallocFreeMemoryEv
 __ZN3WTF28setMainThreadCallbacksPausedEb
 __ZN3WTF29cryptographicallyRandomNumberEv
--- third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def~	2012-12-13 07:06:32.691949290 -0600
+++ third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def	2012-12-14 17:28:39.346932470 -0600
@@ -241,6 +241,7 @@
     ?markChildren@JSWrapperObject@JSC@@EAEXAAVMarkStack@2@@Z
     ?markChildren@ScopeChainNode@JSC@@UAEXAAVMarkStack@2@@Z
     ?materializePropertyMap@Structure@JSC@@AAEXXZ
+    ?monotonicallyIncreasingTime@WTF@@YANXZ
     ?monthFromDayInYear@WTF@@YAHH_N@Z
     ?msToYear@WTF@@YAHN@Z
     ?name@InternalFunction@JSC@@QAEABVUString@2@PAVExecState@2@@Z
--- third_party/WebKit/Source/JavaScriptCore/wtf/CurrentTime.cpp~	2012-12-13 07:06:24.163949585 -0600
+++ third_party/WebKit/Source/JavaScriptCore/wtf/CurrentTime.cpp	2012-12-14 17:28:39.347932484 -0600
@@ -33,7 +33,10 @@
 #include "config.h"
 #include "CurrentTime.h"
 
-#if OS(WINDOWS)
+#if PLATFORM(MAC)
+#include <mach/mach_time.h>
+#include <sys/time.h>
+#elif OS(WINDOWS)
 
 // Windows is first since we want to use hires timers, despite USE(CF)
 // being defined.
@@ -44,35 +47,54 @@
 #include <stdint.h>
 #include <time.h>
 
-#if USE(QUERY_PERFORMANCE_COUNTER)
-#if OS(WINCE)
-extern "C" time_t mktime(struct tm *t);
-#else
-#include <sys/timeb.h>
-#include <sys/types.h>
-#endif
-#endif
-
-#elif PLATFORM(GTK)
-#include <glib.h>
 #elif PLATFORM(WX)
 #include <wx/datetime.h>
-#elif PLATFORM(BREWMP)
-#include <AEEStdLib.h>
+#elif PLATFORM(EFL)
+#include <Ecore.h>
 #else
 #include <sys/time.h>
 #endif
 
+#if PLATFORM(GTK)
+#include <glib.h>
+#endif
+
+#if PLATFORM(QT)
+#include <QElapsedTimer>
+#endif
+
 #if PLATFORM(CHROMIUM)
 #error Chromium uses a different timer implementation
 #endif
-
 namespace WTF {
 
-const double msPerSecond = 1000.0;
-
 #if OS(WINDOWS)
 
+// Number of 100 nanosecond between January 1, 1601 and January 1, 1970.
+static const ULONGLONG epochBias = 116444736000000000ULL;
+static const double hundredsOfNanosecondsPerMillisecond = 10000;
+
+static double lowResUTCTime()
+{
+    FILETIME fileTime;
+
+#if OS(WINCE)
+    GetCurrentFT(&fileTime);
+#else
+    GetSystemTimeAsFileTime(&fileTime);
+#endif
+
+    // As per Windows documentation for FILETIME, copy the resulting FILETIME structure to a
+    // ULARGE_INTEGER structure using memcpy (using memcpy instead of direct assignment can
+    // prevent alignment faults on 64-bit Windows).
+
+    ULARGE_INTEGER dateTime;
+    memcpy(&dateTime, &fileTime, sizeof(dateTime));
+
+    // Windows file times are in 100s of nanoseconds.
+    return (dateTime.QuadPart - epochBias) / hundredsOfNanosecondsPerMillisecond;
+}
+
 #if USE(QUERY_PERFORMANCE_COUNTER)
 
 static LARGE_INTEGER qpcFrequency;
@@ -121,28 +143,6 @@
     return (1000.0 * qpc.QuadPart) / static_cast<double>(qpcFrequency.QuadPart);
 }
 
-static double lowResUTCTime()
-{
-#if OS(WINCE)
-    SYSTEMTIME systemTime;
-    GetSystemTime(&systemTime);
-    struct tm tmtime;
-    tmtime.tm_year = systemTime.wYear - 1900;
-    tmtime.tm_mon = systemTime.wMonth - 1;
-    tmtime.tm_mday = systemTime.wDay;
-    tmtime.tm_wday = systemTime.wDayOfWeek;
-    tmtime.tm_hour = systemTime.wHour;
-    tmtime.tm_min = systemTime.wMinute;
-    tmtime.tm_sec = systemTime.wSecond;
-    time_t timet = mktime(&tmtime);
-    return timet * msPerSecond + systemTime.wMilliseconds;
-#else
-    struct _timeb timebuffer;
-    _ftime(&timebuffer);
-    return timebuffer.time * msPerSecond + timebuffer.millitm;
-#endif
-}
-
 static bool qpcAvailable()
 {
     static bool available;
@@ -201,36 +201,13 @@
 
 #else
 
-static double currentSystemTime()
-{
-    FILETIME ft;
-    GetCurrentFT(&ft);
-
-    // As per Windows documentation for FILETIME, copy the resulting FILETIME structure to a
-    // ULARGE_INTEGER structure using memcpy (using memcpy instead of direct assignment can
-    // prevent alignment faults on 64-bit Windows).
-
-    ULARGE_INTEGER t;
-    memcpy(&t, &ft, sizeof(t));
-
-    // Windows file times are in 100s of nanoseconds.
-    // To convert to seconds, we have to divide by 10,000,000, which is more quickly
-    // done by multiplying by 0.0000001.
-
-    // Between January 1, 1601 and January 1, 1970, there were 369 complete years,
-    // of which 89 were leap years (1700, 1800, and 1900 were not leap years).
-    // That is a total of 134774 days, which is 11644473600 seconds.
-
-    return t.QuadPart * 0.0000001 - 11644473600.0;
-}
-
 double currentTime()
 {
     static bool init = false;
     static double lastTime;
     static DWORD lastTickCount;
     if (!init) {
-        lastTime = currentSystemTime();
+        lastTime = lowResUTCTime();
         lastTickCount = GetTickCount();
         init = true;
         return lastTime;
@@ -269,18 +246,21 @@
     return (double)now.GetTicks() + (double)(now.GetMillisecond() / 1000.0);
 }
 
-#elif PLATFORM(BREWMP)
+#elif PLATFORM(EFL)
+
+double currentTime()
+{
+    return ecore_time_unix_get();
+}
+
+#elif OS(QNX)
 
-// GETUTCSECONDS returns the number of seconds since 1980/01/06 00:00:00 UTC,
-// and GETTIMEMS returns the number of milliseconds that have elapsed since the last
-// occurrence of 00:00:00 local time.
-// We can combine GETUTCSECONDS and GETTIMEMS to calculate the number of milliseconds
-// since 1970/01/01 00:00:00 UTC.
 double currentTime()
 {
-    // diffSeconds is the number of seconds from 1970/01/01 to 1980/01/06
-    const unsigned diffSeconds = 315964800;
-    return static_cast<double>(diffSeconds + GETUTCSECONDS() + ((GETTIMEMS() % 1000) / msPerSecond));
+    struct timespec time;
+    if (clock_gettime(CLOCK_REALTIME, &time))
+        CRASH();
+    return time.tv_sec + time.tv_nsec / 1.0e9;
 }
 
 #else
@@ -293,5 +273,65 @@
 }
 
 #endif
+
+#if PLATFORM(MAC)
+
+double monotonicallyIncreasingTime()
+{
+    // Based on listing #2 from Apple QA 1398.
+    static mach_timebase_info_data_t timebaseInfo;
+    if (!timebaseInfo.denom) {
+        kern_return_t kr = mach_timebase_info(&timebaseInfo);
+        ASSERT_UNUSED(kr, kr == KERN_SUCCESS);
+    }
+    return (mach_absolute_time() * timebaseInfo.numer) / (1.0e9 * timebaseInfo.denom);
+}
+
+#elif PLATFORM(EFL)
+
+double monotonicallyIncreasingTime()
+{
+    return ecore_time_get();
+}
+
+#elif PLATFORM(GTK)
+
+double monotonicallyIncreasingTime()
+{
+    return static_cast<double>(g_get_monotonic_time() / 1000000.0);
+}
+
+#elif PLATFORM(QT)
+
+double monotonicallyIncreasingTime()
+{
+    ASSERT(QElapsedTimer::isMonotonic());
+    static QElapsedTimer timer;
+    return timer.nsecsElapsed() / 1.0e9;
+}
+
+#elif OS(QNX)
+
+double monotonicallyIncreasingTime()
+{
+    struct timespec time;
+    if (clock_gettime(CLOCK_MONOTONIC, &time))
+        CRASH();
+    return time.tv_sec + time.tv_nsec / 1.0e9;
+}
+
+#else
+
+double monotonicallyIncreasingTime()
+{
+    static double lastTime = 0;
+    double currentTimeNow = currentTime();
+    if (currentTimeNow < lastTime)
+        return lastTime;
+    lastTime = currentTimeNow;
+    return currentTimeNow;
+}
+
+#endif
 
 } // namespace WTF
--- third_party/WebKit/Source/JavaScriptCore/wtf/CurrentTime.h~	2012-12-13 07:06:21.954949660 -0600
+++ third_party/WebKit/Source/JavaScriptCore/wtf/CurrentTime.h	2012-12-14 17:28:39.347932484 -0600
@@ -47,22 +47,13 @@
     return currentTime() * 1000.0;
 }
 
-inline void getLocalTime(const time_t* localTime, struct tm* localTM)
-{
-#if COMPILER(MSVC7_OR_LOWER) || COMPILER(MINGW) || OS(WINCE)
-    *localTM = *localtime(localTime);
-#elif COMPILER(MSVC)
-    localtime_s(localTM, localTime);
-#else
-    localtime_r(localTime, localTM);
-#endif
-}
+double monotonicallyIncreasingTime();
 
 } // namespace WTF
 
 using WTF::currentTime;
 using WTF::currentTimeMS;
-using WTF::getLocalTime;
+using WTF::monotonicallyIncreasingTime;
 
 #endif // CurrentTime_h
 
--- third_party/WebKit/Source/JavaScriptCore/wtf/DateMath.cpp~	2012-12-13 07:06:21.959949661 -0600
+++ third_party/WebKit/Source/JavaScriptCore/wtf/DateMath.cpp	2012-12-14 17:28:39.348932486 -0600
@@ -137,6 +137,17 @@
     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
 };
 
+static inline void getLocalTime(const time_t* localTime, struct tm* localTM)
+{
+#if COMPILER(MSVC7_OR_LOWER) || COMPILER(MINGW)
+    *localTM = *localtime(localTime);
+#elif COMPILER(MSVC)
+    localtime_s(localTM, localTime);
+#else
+    localtime_r(localTime, localTM);
+#endif
+}
+
 static inline bool isLeapYear(int year)
 {
     if (year % 4 != 0)
--- third_party/WebKit/Source/WebCore/html/FTPDirectoryDocument.cpp~	2012-12-13 07:09:09.084943875 -0600
+++ third_party/WebKit/Source/WebCore/html/FTPDirectoryDocument.cpp	2012-12-14 17:28:39.349932485 -0600
@@ -177,6 +177,17 @@
     return String::format("%.2f GB", static_cast<float>(bytes)/1000000000);
 }
 
+static inline void getLocalTime(const time_t* localTime, struct tm* localTM)
+{
+#if COMPILER(MSVC7_OR_LOWER) || COMPILER(MINGW)
+    *localTM = *localtime(localTime);
+#elif COMPILER(MSVC)
+    localtime_s(localTM, localTime);
+#else
+    localtime_r(localTime, localTM);
+#endif
+}
+
 static bool wasLastDayOfMonth(int year, int month, int day)
 {
     static int lastDays[] = { 31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
--- third_party/WebKit/Source/WebCore/platform/SharedTimer.h~	2012-12-13 07:09:01.455944139 -0600
+++ third_party/WebKit/Source/WebCore/platform/SharedTimer.h	2012-12-14 17:28:39.349932485 -0600
@@ -41,9 +41,8 @@
         virtual ~SharedTimer() {}
         virtual void setFiredFunction(void (*)()) = 0;
 
-        // The fire time is relative to the classic POSIX epoch of January 1, 1970,
-        // as the result of currentTime() is.
-        virtual void setFireTime(double) = 0;
+        // The fire interval is in seconds relative to the current monotonic clock time.
+        virtual void setFireInterval(double) = 0;
         virtual void stop() = 0;
     };
 
@@ -51,7 +50,7 @@
     // Implemented by port (since it provides the run loop for the main thread).
     // FIXME: make ports implement MainThreadSharedTimer directly instead.
     void setSharedTimerFiredFunction(void (*)());
-    void setSharedTimerFireTime(double);
+    void setSharedTimerFireInterval(double);
     void stopSharedTimer();
 
     // Implementation of SharedTimer for the main thread.
@@ -62,9 +61,9 @@
             setSharedTimerFiredFunction(function);
         }
         
-        virtual void setFireTime(double fireTime)
+        virtual void setFireInterval(double interval)
         {
-            setSharedTimerFireTime(fireTime);
+            setSharedTimerFireInterval(interval);
         }
         
         virtual void stop()
--- third_party/WebKit/Source/WebCore/platform/ThreadTimers.cpp~	2012-12-13 07:08:51.179944495 -0600
+++ third_party/WebKit/Source/WebCore/platform/ThreadTimers.cpp	2012-12-14 17:28:39.350932484 -0600
@@ -31,6 +31,9 @@
 #include "ThreadGlobalData.h"
 #include "Timer.h"
 #include <wtf/CurrentTime.h>
+#include <wtf/MainThread.h>
+
+using namespace std;
 
 namespace WebCore {
 
@@ -81,7 +84,7 @@
     if (m_firingTimers || m_timerHeap.isEmpty())
         m_sharedTimer->stop();
     else
-        m_sharedTimer->setFireTime(m_timerHeap.first()->m_nextFireTime);
+        m_sharedTimer->setFireInterval(max(m_timerHeap.first()->m_nextFireTime - monotonicallyIncreasingTime(), 0.0));
 }
 
 void ThreadTimers::sharedTimerFired()
@@ -97,12 +100,13 @@
         return;
     m_firingTimers = true;
 
-    double fireTime = currentTime();
+    double fireTime = monotonicallyIncreasingTime();
     double timeToQuit = fireTime + maxDurationOfFiringTimers;
 
     while (!m_timerHeap.isEmpty() && m_timerHeap.first()->m_nextFireTime <= fireTime) {
         TimerBase* timer = m_timerHeap.first();
         timer->m_nextFireTime = 0;
+        timer->m_unalignedNextFireTime = 0;
         timer->heapDeleteMin();
 
         double interval = timer->repeatInterval();
@@ -112,7 +116,7 @@
         timer->fired();
 
         // Catch the case where the timer asked timers to fire in a nested event loop, or we are over time limit.
-        if (!m_firingTimers || timeToQuit < currentTime())
+        if (!m_firingTimers || timeToQuit < monotonicallyIncreasingTime())
             break;
     }
 
--- third_party/WebKit/Source/WebCore/platform/Timer.cpp~	2012-12-13 07:08:51.088944498 -0600
+++ third_party/WebKit/Source/WebCore/platform/Timer.cpp	2012-12-14 17:28:39.351932483 -0600
@@ -41,6 +41,8 @@
 
 namespace WebCore {
 
+class TimerHeapReference;
+
 // Timers are stored in a heap data structure, used to implement a priority queue.
 // This allows us to efficiently determine which timer needs to fire the soonest.
 // Then we set a single shared system timer to fire at that time.
@@ -53,115 +55,144 @@
     return threadGlobalData().threadTimers().timerHeap();
 }
 
-// Class to represent elements in the heap when calling the standard library heap algorithms.
-// Maintains the m_heapIndex value in the timers themselves, which allows us to do efficient
-// modification of the heap.
-class TimerHeapElement {
-public:
-    explicit TimerHeapElement(int i)
-        : m_index(i)
-        , m_timer(timerHeap()[m_index])
-    { 
-        checkConsistency(); 
-    }
-
-    TimerHeapElement(const TimerHeapElement&);
-    TimerHeapElement& operator=(const TimerHeapElement&);
-
-    TimerBase* timer() const { return m_timer; }
-
-    void checkConsistency() const
-    {
-        ASSERT(m_index >= 0);
-        ASSERT(m_index < static_cast<int>(timerHeap().size()));
-    }
+// ----------------
 
+class TimerHeapPointer {
+public:
+    TimerHeapPointer(TimerBase** pointer) : m_pointer(pointer) { }
+    TimerHeapReference operator*() const;
+    TimerBase* operator->() const { return *m_pointer; }
 private:
-    TimerHeapElement();
+    TimerBase** m_pointer;
+};
 
-    int m_index;
-    TimerBase* m_timer;
+class TimerHeapReference {
+public:
+    TimerHeapReference(TimerBase*& reference) : m_reference(reference) { }
+    operator TimerBase*() const { return m_reference; }
+    TimerHeapPointer operator&() const { return &m_reference; }
+    TimerHeapReference& operator=(TimerBase*);
+    TimerHeapReference& operator=(TimerHeapReference);
+private:
+    TimerBase*& m_reference;
 };
 
-inline TimerHeapElement::TimerHeapElement(const TimerHeapElement& o)
-    : m_index(-1), m_timer(o.timer())
+inline TimerHeapReference TimerHeapPointer::operator*() const
 {
+    return *m_pointer;
 }
 
-inline TimerHeapElement& TimerHeapElement::operator=(const TimerHeapElement& o)
+inline TimerHeapReference& TimerHeapReference::operator=(TimerBase* timer)
 {
-    TimerBase* t = o.timer();
-    m_timer = t;
-    if (m_index != -1) {
-        checkConsistency();
-        timerHeap()[m_index] = t;
-        t->m_heapIndex = m_index;
-    }
+    m_reference = timer;
+    Vector<TimerBase*>& heap = timerHeap();
+    if (&m_reference >= heap.data() && &m_reference < heap.data() + heap.size())
+        timer->m_heapIndex = &m_reference - heap.data();
     return *this;
 }
 
-inline bool operator<(const TimerHeapElement& a, const TimerHeapElement& b)
+inline TimerHeapReference& TimerHeapReference::operator=(TimerHeapReference b)
 {
-    // The comparisons below are "backwards" because the heap puts the largest 
-    // element first and we want the lowest time to be the first one in the heap.
-    double aFireTime = a.timer()->m_nextFireTime;
-    double bFireTime = b.timer()->m_nextFireTime;
-    if (bFireTime != aFireTime)
-        return bFireTime < aFireTime;
+    TimerBase* timer = b;
+    return *this = timer;
+}
     
-    // We need to look at the difference of the insertion orders instead of comparing the two 
-    // outright in case of overflow. 
-    unsigned difference = a.timer()->m_heapInsertionOrder - b.timer()->m_heapInsertionOrder;
-    return difference < UINT_MAX / 2;
+inline void swap(TimerHeapReference a, TimerHeapReference b)
+{
+    TimerBase* timerA = a;
+    TimerBase* timerB = b;
+
+    // Invoke the assignment operator, since that takes care of updating m_heapIndex.
+    a = timerB;
+    b = timerA;
 }
 
 // ----------------
 
 // Class to represent iterators in the heap when calling the standard library heap algorithms.
-// Returns TimerHeapElement for elements in the heap rather than the TimerBase pointers themselves.
-class TimerHeapIterator : public iterator<random_access_iterator_tag, TimerHeapElement, int> {
+// Uses a custom pointer and reference type that update indices for pointers in the heap.
+class TimerHeapIterator : public iterator<random_access_iterator_tag, TimerBase*, ptrdiff_t, TimerHeapPointer, TimerHeapReference> {
 public:
-    TimerHeapIterator() : m_index(-1) { }
-    TimerHeapIterator(int i) : m_index(i) { checkConsistency(); }
-
-    TimerHeapIterator& operator++() { checkConsistency(); ++m_index; checkConsistency(); return *this; }
-    TimerHeapIterator operator++(int) { checkConsistency(); checkConsistency(1); return m_index++; }
+    explicit TimerHeapIterator(TimerBase** pointer) : m_pointer(pointer) { checkConsistency(); }
 
-    TimerHeapIterator& operator--() { checkConsistency(); --m_index; checkConsistency(); return *this; }
-    TimerHeapIterator operator--(int) { checkConsistency(); checkConsistency(-1); return m_index--; }
+    TimerHeapIterator& operator++() { checkConsistency(); ++m_pointer; checkConsistency(); return *this; }
+    TimerHeapIterator operator++(int) { checkConsistency(1); return TimerHeapIterator(m_pointer++); }
 
-    TimerHeapIterator& operator+=(int i) { checkConsistency(); m_index += i; checkConsistency(); return *this; }
-    TimerHeapIterator& operator-=(int i) { checkConsistency(); m_index -= i; checkConsistency(); return *this; }
+    TimerHeapIterator& operator--() { checkConsistency(); --m_pointer; checkConsistency(); return *this; }
+    TimerHeapIterator operator--(int) { checkConsistency(-1); return TimerHeapIterator(m_pointer--); }
 
-    TimerHeapElement operator*() const { return TimerHeapElement(m_index); }
-    TimerHeapElement operator[](int i) const { return TimerHeapElement(m_index + i); }
+    TimerHeapIterator& operator+=(ptrdiff_t i) { checkConsistency(); m_pointer += i; checkConsistency(); return *this; }
+    TimerHeapIterator& operator-=(ptrdiff_t i) { checkConsistency(); m_pointer -= i; checkConsistency(); return *this; }
 
-    int index() const { return m_index; }
+    TimerHeapReference operator*() const { return TimerHeapReference(*m_pointer); }
+    TimerHeapReference operator[](ptrdiff_t i) const { return TimerHeapReference(m_pointer[i]); }
+    TimerBase* operator->() const { return *m_pointer; }
 
-    void checkConsistency(int offset = 0) const
+private:
+    void checkConsistency(ptrdiff_t offset = 0) const
     {
-        ASSERT_UNUSED(offset, m_index + offset >= 0);
-        ASSERT_UNUSED(offset, m_index + offset <= static_cast<int>(timerHeap().size()));
+        ASSERT(m_pointer >= timerHeap().data());
+        ASSERT(m_pointer <= timerHeap().data() + timerHeap().size());
+        ASSERT_UNUSED(offset, m_pointer + offset >= timerHeap().data());
+        ASSERT_UNUSED(offset, m_pointer + offset <= timerHeap().data() + timerHeap().size());
     }
 
-private:
-    int m_index;
+    friend bool operator==(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator!=(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator<(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator>(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator<=(TimerHeapIterator, TimerHeapIterator);
+    friend bool operator>=(TimerHeapIterator, TimerHeapIterator);
+    
+    friend TimerHeapIterator operator+(TimerHeapIterator, size_t);
+    friend TimerHeapIterator operator+(size_t, TimerHeapIterator);
+    
+    friend TimerHeapIterator operator-(TimerHeapIterator, size_t);
+    friend ptrdiff_t operator-(TimerHeapIterator, TimerHeapIterator);
+
+    TimerBase** m_pointer;
 };
 
-inline bool operator==(TimerHeapIterator a, TimerHeapIterator b) { return a.index() == b.index(); }
-inline bool operator!=(TimerHeapIterator a, TimerHeapIterator b) { return a.index() != b.index(); }
-inline bool operator<(TimerHeapIterator a, TimerHeapIterator b) { return a.index() < b.index(); }
+inline bool operator==(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer == b.m_pointer; }
+inline bool operator!=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer != b.m_pointer; }
+inline bool operator<(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer < b.m_pointer; }
+inline bool operator>(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer > b.m_pointer; }
+inline bool operator<=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer <= b.m_pointer; }
+inline bool operator>=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer >= b.m_pointer; }
 
-inline TimerHeapIterator operator+(TimerHeapIterator a, int b) { return a.index() + b; }
-inline TimerHeapIterator operator+(int a, TimerHeapIterator b) { return a + b.index(); }
+inline TimerHeapIterator operator+(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer + b); }
+inline TimerHeapIterator operator+(size_t a, TimerHeapIterator b) { return TimerHeapIterator(a + b.m_pointer); }
 
-inline TimerHeapIterator operator-(TimerHeapIterator a, int b) { return a.index() - b; }
-inline int operator-(TimerHeapIterator a, TimerHeapIterator b) { return a.index() - b.index(); }
+inline TimerHeapIterator operator-(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer - b); }
+inline ptrdiff_t operator-(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer - b.m_pointer; }
+
+// ----------------
+
+class TimerHeapLessThanFunction {
+public:
+    bool operator()(TimerBase*, TimerBase*) const;
+};
+
+inline bool TimerHeapLessThanFunction::operator()(TimerBase* a, TimerBase* b) const
+{
+    // The comparisons below are "backwards" because the heap puts the largest 
+    // element first and we want the lowest time to be the first one in the heap.
+    double aFireTime = a->m_nextFireTime;
+    double bFireTime = b->m_nextFireTime;
+    if (bFireTime != aFireTime)
+        return bFireTime < aFireTime;
+    
+    // We need to look at the difference of the insertion orders instead of comparing the two 
+    // outright in case of overflow. 
+    unsigned difference = a->m_heapInsertionOrder - b->m_heapInsertionOrder;
+    return difference < numeric_limits<unsigned>::max() / 2;
+}
 
 // ----------------
 
 TimerBase::TimerBase()
     : m_nextFireTime(0)
+    , m_unalignedNextFireTime(0)
     , m_repeatInterval(0)
     , m_heapIndex(-1)
 #ifndef NDEBUG
@@ -181,7 +212,7 @@
     ASSERT(m_thread == currentThread());
 
     m_repeatInterval = repeatInterval;
-    setNextFireTime(currentTime() + nextFireInterval);
+    setNextFireTime(monotonicallyIncreasingTime() + nextFireInterval);
 }
 
 void TimerBase::stop()
@@ -199,7 +230,7 @@
 double TimerBase::nextFireInterval() const
 {
     ASSERT(isActive());
-    double current = currentTime();
+    double current = monotonicallyIncreasingTime();
     if (m_nextFireTime < current)
         return 0;
     return m_nextFireTime - current;
@@ -225,7 +256,8 @@
 {
     ASSERT(m_nextFireTime != 0);
     checkHeapIndex();
-    push_heap(TimerHeapIterator(0), TimerHeapIterator(m_heapIndex + 1));
+    TimerBase** heapData = timerHeap().data();
+    push_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + m_heapIndex + 1), TimerHeapLessThanFunction());
     checkHeapIndex();
 }
 
@@ -274,17 +306,23 @@
 {
     ASSERT(this == timerHeap().first());
     checkHeapIndex();
-    pop_heap(TimerHeapIterator(0), TimerHeapIterator(timerHeap().size()));
+    Vector<TimerBase*>& heap = timerHeap();
+    TimerBase** heapData = heap.data();
+    pop_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + heap.size()), TimerHeapLessThanFunction());
     checkHeapIndex();
     ASSERT(this == timerHeap().last());
 }
 
-void TimerBase::setNextFireTime(double newTime)
+void TimerBase::setNextFireTime(double newUnalignedTime)
 {
     ASSERT(m_thread == currentThread());
 
+    if (m_unalignedNextFireTime != newUnalignedTime)
+        m_unalignedNextFireTime = newUnalignedTime;
+
     // Keep heap valid while changing the next-fire time.
     double oldTime = m_nextFireTime;
+    double newTime = alignedFireTime(newUnalignedTime);
     if (oldTime != newTime) {
         m_nextFireTime = newTime;
         static unsigned currentHeapInsertionOrder;
@@ -316,5 +354,16 @@
     threadGlobalData().threadTimers().fireTimersInNestedEventLoop();
 }
 
+void TimerBase::didChangeAlignmentInterval()
+{
+    setNextFireTime(m_unalignedNextFireTime);
+}
+
+double TimerBase::nextUnalignedFireInterval() const
+{
+    ASSERT(isActive());
+    return max(m_unalignedNextFireTime - monotonicallyIncreasingTime(), 0.0);
+}
+
 } // namespace WebCore
 
--- third_party/WebKit/Source/WebCore/platform/Timer.h~	2012-12-13 07:09:01.701944130 -0600
+++ third_party/WebKit/Source/WebCore/platform/Timer.h	2012-12-14 17:28:39.351932483 -0600
@@ -50,16 +50,21 @@
     bool isActive() const;
 
     double nextFireInterval() const;
+    double nextUnalignedFireInterval() const;
     double repeatInterval() const { return m_repeatInterval; }
 
     void augmentFireInterval(double delta) { setNextFireTime(m_nextFireTime + delta); }
     void augmentRepeatInterval(double delta) { augmentFireInterval(delta); m_repeatInterval += delta; }
 
+    void didChangeAlignmentInterval();
+
     static void fireTimersInNestedEventLoop();
 
 private:
     virtual void fired() = 0;
 
+    virtual double alignedFireTime(double fireTime) const { return fireTime; }
+
     void checkConsistency() const;
     void checkHeapIndex() const;
 
@@ -76,6 +81,7 @@
     void heapPopMin();
 
     double m_nextFireTime; // 0 if inactive
+    double m_unalignedNextFireTime; // m_nextFireTime not considering alignment interval
     double m_repeatInterval; // 0 if not repeating
     int m_heapIndex; // -1 if not in heap
     unsigned m_heapInsertionOrder; // Used to keep order among equal-fire-time timers
@@ -84,9 +90,9 @@
     ThreadIdentifier m_thread;
 #endif
 
-    friend class TimerHeapElement;
     friend class ThreadTimers;
-    friend bool operator<(const TimerHeapElement&, const TimerHeapElement&);
+    friend class TimerHeapLessThanFunction;
+    friend class TimerHeapReference;
 };
 
 template <typename TimerFiredClass> class Timer : public TimerBase {
@@ -109,6 +115,52 @@
     return m_nextFireTime;
 }
 
+template <typename TimerFiredClass> class DeferrableOneShotTimer : private TimerBase {
+public:
+    typedef void (TimerFiredClass::*TimerFiredFunction)(DeferrableOneShotTimer*);
+
+    DeferrableOneShotTimer(TimerFiredClass* o, TimerFiredFunction f, double delay)
+        : m_object(o)
+        , m_function(f)
+        , m_delay(delay)
+        , m_shouldRestartWhenTimerFires(false)
+    {
+    }
+
+    void restart()
+    {
+        // Setting this boolean is much more efficient than calling startOneShot
+        // again, which might result in rescheduling the system timer which
+        // can be quite expensive.
+
+        if (isActive()) {
+            m_shouldRestartWhenTimerFires = true;
+            return;
+        }
+        startOneShot(m_delay);
+    }
+
+    using TimerBase::stop;
+    using TimerBase::isActive;
+private:
+    virtual void fired()
+    {
+        if (m_shouldRestartWhenTimerFires) {
+            m_shouldRestartWhenTimerFires = false;
+            startOneShot(m_delay);
+            return;
+        }
+
+        (m_object->*m_function)(this);
+    }
+
+    TimerFiredClass* m_object;
+    TimerFiredFunction m_function;
+
+    double m_delay;
+    bool m_shouldRestartWhenTimerFires;
+};
+
 }
 
 #endif
--- third_party/WebKit/Source/WebCore/platform/chromium/PlatformBridge.h~	2012-12-13 07:08:55.798944335 -0600
+++ third_party/WebKit/Source/WebCore/platform/chromium/PlatformBridge.h	2012-12-17 08:12:33.818947311 -0600
@@ -230,7 +230,7 @@
 
     // SharedTimers -------------------------------------------------------
     static void setSharedTimerFiredFunction(void (*func)());
-    static void setSharedTimerFireTime(double);
+    static void setSharedTimerFireInterval(double);
     static void stopSharedTimer();
 
     // StatsCounters ------------------------------------------------------
@@ -244,6 +244,7 @@
 
     // SystemTime ---------------------------------------------------------
     static double currentTime();
+	static double monotonicallyIncreasingTime();
 
     // Theming ------------------------------------------------------------
 #if OS(WINDOWS)
--- third_party/WebKit/Source/WebCore/platform/chromium/SharedTimerChromium.cpp~	2012-12-13 07:08:55.803944335 -0600
+++ third_party/WebKit/Source/WebCore/platform/chromium/SharedTimerChromium.cpp	2012-12-14 17:28:39.352932483 -0600
@@ -35,9 +35,9 @@
     PlatformBridge::setSharedTimerFiredFunction(f);
 }
 
-void setSharedTimerFireTime(double fireTime)
+void setSharedTimerFireInterval(double fireInterval)
 {
-    PlatformBridge::setSharedTimerFireTime(fireTime);
+    PlatformBridge::setSharedTimerFireInterval(fireInterval);
 }
 
 void stopSharedTimer()
--- third_party/WebKit/Source/WebCore/platform/chromium/SystemTimeChromium.cpp~	2012-12-13 07:08:55.814944334 -0600
+++ third_party/WebKit/Source/WebCore/platform/chromium/SystemTimeChromium.cpp	2012-12-17 08:23:42.094924173 -0600
@@ -42,6 +42,11 @@
     return PlatformBridge::currentTime();
 }
 
+double monotonicallyIncreasingTime()
+{
+    return PlatformBridge::monotonicallyIncreasingTime();
+}
+
 float userIdleTime()
 {
     // Needed for back/forward cache, which we currently have disabled.
--- third_party/WebKit/Source/WebCore/platform/gtk/SharedTimerGtk.cpp~	2012-12-13 07:08:57.986944259 -0600
+++ third_party/WebKit/Source/WebCore/platform/gtk/SharedTimerGtk.cpp	2012-12-14 17:28:39.352932483 -0600
@@ -50,18 +50,11 @@
     return FALSE;
 }
 
-void setSharedTimerFireTime(double fireTime)
+void setSharedTimerFireInterval(double interval)
 {
     ASSERT(sharedTimerFiredFunction);
 
-    double interval = fireTime - currentTime();
-    guint intervalInMS;
-    if (interval < 0)
-        intervalInMS = 0;
-    else {
-        interval *= 1000;
-        intervalInMS = (guint)interval;
-    }
+    guint intervalInMS = static_cast<guint>(interval * 1000);
 
     stopSharedTimer();
     sharedTimer = g_timeout_add_full(GDK_PRIORITY_REDRAW, intervalInMS, timeout_cb, 0, 0);
@@ -69,12 +62,11 @@
 
 void stopSharedTimer()
 {
-    gboolean s = FALSE;
     if (sharedTimer == 0)
         return;
 
-    s = g_source_remove(sharedTimer);
-    ASSERT(s);
+    gboolean removedSource = g_source_remove(sharedTimer);
+    ASSERT_UNUSED(removedSource, removedSource);
     sharedTimer = 0;
 }
 
--- third_party/WebKit/Source/WebCore/platform/win/SharedTimerWin.cpp~	2012-12-13 07:08:43.381944765 -0600
+++ third_party/WebKit/Source/WebCore/platform/win/SharedTimerWin.cpp	2012-12-14 17:28:39.353932483 -0600
@@ -146,21 +146,16 @@
         PostMessage(timerWindowHandle, timerFiredMessage, 0, 0);
 }
 
-void setSharedTimerFireTime(double fireTime)
+void setSharedTimerFireInterval(double interval)
 {
     ASSERT(sharedTimerFiredFunction);
 
-    double interval = fireTime - currentTime();
     unsigned intervalInMS;
-    if (interval < 0)
-        intervalInMS = 0;
-    else {
         interval *= 1000;
         if (interval > USER_TIMER_MAXIMUM)
             intervalInMS = USER_TIMER_MAXIMUM;
         else
-            intervalInMS = (unsigned)interval;
-    }
+        intervalInMS = static_cast<unsigned>(interval);
 
     initializeOffScreenTimerWindow();
     bool timerSet = false;
--- third_party/WebKit/Source/WebCore/workers/WorkerRunLoop.cpp~	2012-12-13 07:09:04.059944049 -0600
+++ third_party/WebKit/Source/WebCore/workers/WorkerRunLoop.cpp	2012-12-14 17:28:39.353932483 -0600
@@ -39,6 +39,7 @@
 #include "WorkerRunLoop.h"
 #include "WorkerContext.h"
 #include "WorkerThread.h"
+#include <wtf/CurrentTime.h>
 
 namespace WebCore {
 
@@ -52,7 +53,7 @@
 
     // SharedTimer interface.
     virtual void setFiredFunction(void (*function)()) { m_sharedTimerFunction = function; }
-    virtual void setFireTime(double fireTime) { m_nextFireTime = fireTime; }
+    virtual void setFireInterval(double interval) { m_nextFireTime = interval + currentTime(); }
     virtual void stop() { m_nextFireTime = 0; }
 
     bool isActive() { return m_sharedTimerFunction && m_nextFireTime; }
--- third_party/WebKit/Source/WebKit/chromium/public/WebKitClient.h~	2012-12-13 07:07:16.225947780 -0600
+++ third_party/WebKit/Source/WebKit/chromium/public/WebKitClient.h	2012-12-14 17:28:39.354932483 -0600
@@ -263,6 +263,7 @@
 
     // Wall clock time in seconds since the epoch.
     virtual double currentTime() { return 0; }
+	virtual double monotonicallyIncreasingTime() { return 0; }
 
     virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)
     {
@@ -272,7 +273,7 @@
 
     // Delayed work is driven by a shared timer.
     virtual void setSharedTimerFiredFunction(void (*func)()) { }
-    virtual void setSharedTimerFireTime(double fireTime) { }
+    virtual void setSharedTimerFireInterval(double fireInterval) { }
     virtual void stopSharedTimer() { }
 
     // Callable from a background WebKit thread.
--- third_party/WebKit/Source/WebKit/chromium/src/ChromiumCurrentTime.cpp~	2012-12-13 07:07:12.691947905 -0600
+++ third_party/WebKit/Source/WebKit/chromium/src/ChromiumCurrentTime.cpp	2012-12-14 17:28:39.354932483 -0600
@@ -41,4 +41,10 @@
     return WebKit::webKitClient()->currentTime();
 }
 
+double monotonicallyIncreasingTime()
+{
+    return WebKit::webKitClient()->monotonicallyIncreasingTime();
+}
+
 }  // namespace WTF
+
--- third_party/WebKit/Source/WebKit/chromium/src/PlatformBridge.cpp~	2012-12-13 07:07:12.328947916 -0600
+++ third_party/WebKit/Source/WebKit/chromium/src/PlatformBridge.cpp	2012-12-17 08:13:06.891946166 -0600
@@ -646,9 +646,9 @@
     webKitClient()->setSharedTimerFiredFunction(func);
 }
 
-void PlatformBridge::setSharedTimerFireTime(double fireTime)
+void PlatformBridge::setSharedTimerFireInterval(double fireInterval)
 {
-    webKitClient()->setSharedTimerFireTime(fireTime);
+    webKitClient()->setSharedTimerFireInterval(fireInterval);
 }
 
 void PlatformBridge::stopSharedTimer()
@@ -692,6 +692,11 @@
     return webKitClient()->currentTime();
 }
 
+double PlatformBridge::monotonicallyIncreasingTime() 
+{
+    return webKitClient()->monotonicallyIncreasingTime();
+}
+
 // Theming --------------------------------------------------------------------
 
 #if OS(WINDOWS)
